[toc]

# [两数之和](https://leetcode-cn.com/problems/two-sum/)

+ 方法一：最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

**使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)到O(1)** 

时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)地寻找 target - x。

空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。

# [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

其中，答案链表处相应位置的数字为 (n1+n2+carry)**%**10，而新的进位值为 (n1+n2+carry)**/**10
如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0**(没必要实际new节点)**。

此外，如果链表遍历结束后，有 carry>0，还需要在答案链表的后面附加一个节点，节点的值为 carry。

# [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！我们就可以使用**滑动窗口**来解决这个问题了

假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk那么当我们选择第 k+1个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk

使用一种数据结构来判断 **是否有重复的字符，常用的数据结构为哈希集合**（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）

时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。

空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在[0,128) 内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。

# [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

![动态规划导图](D:\研究生\学习总结\「动态规划」问题思考方向.png)

> 如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有**最优子结构**。
> 　　　　　　　　　　　　　　　　　　　　　　——算法导论，15.3 动态规划原理

以下解法中「暴力算法」是基础，**动态规划**必须掌握，**中心扩散**方法要会写；
「Manacher 算法」仅用于扩宽视野，绝大多数的算法面试中，面试官都不会要求写这个方法（除非面试者是竞赛选手）。



# [Z字形变换](https://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/)

+ 法一：解决方案为：**模拟这个行索引的变化**，在遍历 `s` 中把每个字符填到正确的行 `res[i]` 。

+ 法二：[行号规律](https://leetcode-cn.com/problems/zigzag-conversion/solution/6-z-zi-xing-bian-huan-c-c-by-bian-bian-xiong/)



# [反转链表](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/)

链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。

思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。

+ 方法一：使用「206. 反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。如图所示：，缺点是需要遍历两遍

+ 方法二：一次遍历「穿针引线」反转链表（**头插法**）

# [整数反转](https://leetcode-cn.com/problems/reverse-integer/)

需要注意一点：正负数取模时，对于负数，余数是负数，商要向0靠，与我的直觉不同。所以在此题中，正负数不需要分开处理。

# [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/)

双指针法：从两头向中间移动(详见leetcode)

# [三数之和](https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/)

![三数之和](D:\研究生\学习总结\Arrays.png)

「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；

第三重循环枚举到的元素不小于当前第二重循环枚举到的元素

也就是说，我们枚举的三元组 (a, b, c)满足 a≤b≤c，保证了只有 (a, b, c)这个顺序会被枚举到，而 (b, a, c)、(c,b,a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。

（感悟：可以在既有的直觉想法上改进，避免重复可以通过定序这个办法去重）

同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复

我们可以从小到大枚举 b，**同时**从大到小枚举 c，即**第二重循环和第三重循环实际上是并列的关系**。我们就可以保持第二重循环不变，而将**第三重循环变成一个从数组最右端开始向左移动的指针**，这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)减少至 O(N)

时间复杂度：O(N^2)，其中 N 是数组nums 的长度。

空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 )O(logN)。然而我们修改了输入的数组nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)



# [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/)

+ 回溯法：哈希表存储数字对应的字母，然后回溯

回溯过程中维护一个字符串，表示已有的字母排列，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。

回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。



# [下一个排列](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/)

+ 方法一：两遍扫描

注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。(初步的朴素想法，让他变大)

同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。(第二步朴素的想法，变化幅度尽可能小)

以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：

我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。

当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。

具体地，我们这样描述该算法，对于长度为 n的排列 a：

首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] < a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。（第一步遍历）

如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] < a[j]。这样「较大数」即为 a[j]。（第二步遍历）

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)使其变为升序，而无需对该区间进行排序。（原地排序）

如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。（特殊情况）



# [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/)

但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。(一长一短)

有序的部分正常二分查找，无序的部分相当于问题规模变小，也是一长一短，根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 `target` 在不在这个部分：



# [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/)

二分查找到target之后不要线性查找，这是个误区。应该继续二分查找。

考虑target 开始和结束位置，其实我们要找的就是数组中「第一个等于target 的位置」（记为 leftIdx）和「第一个大于target 的位置减一」（记为rightIdx）。

# [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/solution/)

+ 法一：异位词的区别在于字母相同，顺序不同，所以先排序，结果相同的字母为一组。

使用HashMap映射，key为排序结果，value为字母组。

记忆函数：

list=map.getOrDefault(key,value)

map.put()key相同就会覆盖，因为hashMap不允许key重复

map.values()返回所有values



# [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)

+ 法一：动态规划

我们用 f(i) 代表以第 i个数结尾的「连续子数组的最大和」,结果就是max{f(i)}

![image-20210406111336031](D:\研究生\学习总结\image-20210406111336031.png)

考虑到 f(i)只和 f(i-1) 相关，于是我们可以只用一个变量pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。

# [跳跃游戏](https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/)

+ 贪心法

每一个可以到达的位置 x，它使得 x+1, x+2, …… x+nums[x] 这些连续的位置都可以到达。

依次遍历数组中的每一个位置，并实时维护 **最远可以到达的位置**

对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用x+nums[x] 更新 最远可以到达的位置。

 **最远可以到达的位置** 大于等于数组中的最后一个位置，那就说明最后一个位置可达，



# [不同路径](https://leetcode-cn.com/problems/unique-paths/)

**状态**：我们用 f(*i*,*j*) 表示从左上角走到 (*i*,*j*) 的路径数量

**状态转移方程**：*f*(*i*,*j*)=*f*(*i*−1,*j*)+*f*(*i*,*j*−1)

 *f*(0,0)=1，即从左上角走到左上角有一种方法。

为了方便代码编写，我们可以将所有的 f*(0,*j*) 以及 f*(*i*,0) 都设置为边界条件，它们的值均为 11。

类似动态规划[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)



# [颜色分类](https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/)

经典荷兰国旗问题

最朴素想法：我们可以统计出数组中 0，1，2 的个数，再根据它们的数量，重写整个数组。



+ 法一：单指针：遍历两遍，第一遍把0都放在头部，第二步把1放在0后边

+ 法二：双指针：遍历一次，用指针 p0 来交换 0，p1 来交换 1，初始值都为 0
  + 找到0时注意两点：1.p0<p1，需要再将num[i]与p1交换
  + 2.无论是否有 p0<p1，我们需要将 p0 和 p1 均向后移动一个位置，而不是仅将 p0 向后移动一个位置。



# [回溯，DFS，DP区分](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)



引入一个队列，这是把递归程序改写成迭代程序的常用方法



# [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/)

算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。

    将左子树插入到右子树的地方
    将原来的右子树接到左子树的最右边节点
    考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null

​    1

   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5



[单词拆分](https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/)

状态表示求解问题的某个阶段

做分类讨论，当前问题分成几个子问题，子问题的最优解构成当前最优解。

定义dp,dp[i]表示前i个字符可以由单词列表组合，状态转移方程：dp[i]=dp[j]&&j到i之间的子串在单词表中

边界dp[0]为真，**定义初始化状态可以考虑多加一行数据，避免复杂的初始化讨论**

哈希表总结：`hashset`对于**查找**一个字符串是否出现在给定的字符串**列表**里一般可以考虑哈希表来快速判断

```java
public HashSet(Collection<? extends E> c) {//hashset构造器
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
```

[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/)

+ HashSet 遍历过的节点加入Set,如果曾经加入过，则表示有环。
+ 快慢指针，快指针一次移动两步，慢指针一次一部，无环则快指针先到结尾，有环则快慢指针最终都进入环，然后若干轮后相遇



[环形链表]()

+ 快慢指针 需要**数学公式推导**

我们使用两个指针，fast和slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。

如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc

![快慢指针](D:\研究生\学习总结\快慢指针.png)

>解释为什么没走完一圈就会相遇，可以从相对速度的角度考虑，相对速度为1，距离x,小于圈长

根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有

a+(n+1)b+nc=2(a+b)  ⟹  a=c+(n−1)(b+c)

有了 a=c+(n−1)(b+c)的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。

因此，当发现 slow与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。

[LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/)

HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供**有序**，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照**插入的顺序**，一种是按照**读取的顺序**（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个**双向链表** 来维护这个顺序的，在每次插入、删除后，都会调用三个个函数来进行 双向链表的维护 

其次，我再介绍一下 LinkedHashMap 的构造函数！
其主要是两个构造方法，一个是继承 HashMap ，一个是可以选择 accessOrder 的值(默认 false，代表按照插入顺序排序)来确定是按插入顺序还是读取顺序排序。

```java
/**
 * //调用父类HashMap的构造方法。
 * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
 * with the default initial capacity (16) and load factor (0.75).
 */
public LinkedHashMap() {
    super();
    accessOrder = false;
}
// 这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true
// initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
```

主体意思就是我们要继承 LinkedHashMap，然后复写 removeEldestEntry()函数，就能拥有我们自己的缓存策略！

通过上述代码，我们就已经知道了只要复写 removeEldestEntry() 即可，而条件就是 map 的大小不超过 给定的容量，超过了就得使用 LRU 了！然后根据题目给定的语句构造和调用：

很明显我们只需要直接继承父类的put函数即可，因为题目没有特殊要求，故可以不写！

所以我们可以调用 LinkedHashMap 中的 getOrDefault()，完美符合这个要求，即当key不存在时会返回默认值 -1。

至此，我们就基本完成了本题的要求，只要写一个构造函数即可，答案的 super(capacity, 0.75F, true);



[排序链表]()

```java
//插入排序，时间复杂度o(n^2)空间复杂度o(1)
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null)
            return head;
        ListNode hhead=new ListNode(Integer.MIN_VALUE,head);
        ListNode preHead=head;//prehead和head成对处理
        head=head.next;//从第二个节点开始遍历
        while(head!=null){
            if(preHead.val<=head.val) {//遍历节点比已遍历节点都大
                preHead=head;
                head = head.next;
            }
            else {
                ListNode pre = hhead, cur = pre.next;//缺点是每次从头遍历
                while (cur.val < head.val) {
                    pre = cur;
                    cur = cur.next;
                }
                pre.next = head;
                preHead.next=head.next;
                head.next = cur;
                head=preHead.next;
            }
        }
        return hhead.next;
    }
}
```

```java
//自顶向下归并，时间复杂度o(nlogn),空间复杂度o(logn)
class Solution {
    public ListNode sortList(ListNode head) {
        return sortList(head,null);
    }
    public ListNode sortList(ListNode head,ListNode tail){//这里相当于[head,tail)
        if(head==null)//空链表
            return head;
        if(head.next==tail){//链表只有单个节点
            head.next=null;//掐断
            return head;
        }
        ListNode slow=head,fast=head;//快慢指针找中间节点
        while(fast!=tail){
            slow=slow.next;
            fast=fast.next;
            if(fast!=tail){
                fast=fast.next;
            }
        }
        ListNode mid=slow;
        ListNode list1=sortList(head,mid);
        ListNode list2=sortList(mid,tail);
        ListNode list=merge(list1,list2);
        return list;
    }
    public ListNode merge(ListNode list1,ListNode list2){//两个排序链表归并
        ListNode hhead=new ListNode();
        ListNode htail=hhead;

        while (list1!=null||list2!=null){
            if(list1==null){
                htail.next=list2;
                break;
            }
            if(list2==null){
                htail.next=list1;
                break;
            }
            if(list1.val< list2.val){
                htail.next=list1;
                list1=list1.next;
            }
            else{
                htail.next=list2;
                list2=list2.next;
            }
            htail=htail.next;
        }
        return hhead.next;
    }
}
```

```java
//注意此处的merge函数归并的是两条独立成型的链表
//所以在子长度链表归并前，要处理到和主线断开，同时要用pre节点记录，防止链表彻底断掉。
class Solution {
    public ListNode sortList(ListNode head) {
        int length;
        ListNode node=head;
        for(length=0;node!=null;node=node.next,length++);
        ListNode hhead=new ListNode(0,head);
        for(int sublength=1;sublength<length;sublength<<=1){
            ListNode cur=hhead.next;//此处不能用head赋值，因为head引用的节点会移动
            ListNode pre=hhead;
            while(cur!=null){//cur扫描节点，执行一遍代表执行一个归并
                ListNode list1=cur;
                for(int i=1;i<sublength&&cur.next!=null;i++){
                    cur=cur.next;
                }
                ListNode list2=cur.next;//此处list2可能为空
                cur.next=null;//断开第一个链表和第二个链表
                cur=list2;
                for(int i=1;i<sublength&&cur!=null&&cur.next!=null;i++){//需要增加对cur非空的判断
                    cur=cur.next;
                }
                ListNode temp=null;//记录第二个链表后边的链表头
                if(cur!=null)
                {
                    temp=cur.next;
                    cur.next=null;//断开第二个链表和后续链表
                }
                ListNode list=merge(list1,list2);//归并出一条完整链表
                pre.next=list;//挂在前一对归并结果的尾部
                while(pre.next!=null){
                    pre=pre.next;//更新到当前归并结果尾部，为了下一组归并结果接着挂上来
                }
                cur=temp;//更新扫描起点到新的子链表
            }
        }
        return hhead.next;
    }
    public ListNode merge(ListNode list1,ListNode list2){
        ListNode hhead=new ListNode();
        ListNode htail=hhead;

        while (list1!=null||list2!=null){
            if(list1==null){//其中一条链表归并完毕，另一条链表直接挂上尾部即可
                htail.next=list2;
                break;
            }
            if(list2==null){//同上
                htail.next=list1;
                break;
            }
            if(list1.val< list2.val){
                htail.next=list1;
                list1=list1.next;
            }
            else{
                htail.next=list2;
                list2=list2.next;
            }
            htail=htail.next;
        }
        return hhead.next;
    }
}
```

如果我们用 fmax⁡(i) 来表示以第 i 个元素结尾的乘积最大子数组的乘积，a 表示输入参数 nums，那么根据「53. 最大子序和」的经验，我们很容易推导出这样的状态转移方程：

fmax⁡(i)=max{fmax(i−1)×ai,ai}

它表示以第 i 个元素结尾的乘积最大子数组的乘积可以考虑 ai 加入前面的 fmax⁡(i−1)对应的一段，或者单独成为一段，这里两种情况下取最大值。求出所有的 fmax⁡(i) 之后选取最大的一个作为答案。

可是在这里，这样做是错误的。为什么呢？

因为这里的定义并**不满足「最优子结构」**。具体地讲，如果 a={5,6,−3,4,−3}，那么此时fmax 对应的序列是 {5,30,−3,4,−3}，按照前面的算法我们可以得到答案为 30，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 −3所对应的 fmax值既不是 −3，也不是 4×−3，而是 5×30×(−3)×4×(−3)。所以我们得到了一个结论：当前位置的最优解未必是由前一个位置的最优解转移得到的。

我们可以根据正负性进行分类讨论。

考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 fmin⁡(i)，它表示以第 iii 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

fmax(i)=max{fmax(i-1)\*a(i),fmin(i-1)\*a(i),a(i)}

fmin(i)=min{fmin(i-1)\*a(i),fmax(i-1)*a(i),a(i)}



# [多数元素](https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/)

hashmap

时间复杂度o(n)空间复杂度o(n)

排序

时间复杂度o(nlogn)空间复杂度o(logn)或o(1)堆排序

投票法

candidate count

# [打家劫舍](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/)

## 动态规划

首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。

如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k>2)间房屋，有两个选项：

    偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2间房屋的最高总金额与第 k 间房屋的金额之和。
    
    不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。

# [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/)

## 统计深度优先遍历次数

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，**每个搜索到的 1 都会被重新标记为 0**。

最终岛屿的数量就是我们进行深度优先搜索的次数。

时间复杂度 o(mn)

空间复杂度o(mn)最坏情况整个表格都是陆地

## 广度优先

超时问题：得第一时间标记走过，不然队列中会产生许多重复的坐标，数量急剧上升

```java
class Solution {
    public int numIslands(char[][] grid) {
        int row=grid.length;
        int col=grid[0].length;
        int num=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]=='1'){
                    num++;
                    grid[i][j]='0';//第一时间标记走过了
                    Queue<Integer> queue=new LinkedList<>();
                    queue.offer(i*col+j);
                    while(!queue.isEmpty()){
                        int loc=queue.poll();
                        int m=loc/col;
                        int n=loc%col;
                        int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
                        for (int k = 0; k < 4; k++) {
                            int newi=m+ direction[k][0];
                            int newj=n + direction[k][1];
                            if(newi>=0&&newi<row&&newj>=0&&newj<col&&grid[newi][newj]=='1') {
                                queue.offer(newi * col + newj);
                                grid[newi][newj]='0';
                            }
                        }
                    }
                }
            }
        }
        return num;
    }
}
```

# [岛屿问题](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

网格类问题DFS的通用解法

网格结构类似与四叉树，超出网格范围类似与root==null

避免重复遍历：打标记

## 岛屿最大面积：

这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。

## 填海造陆：

可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个 7 是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该标记岛屿的索引（下标），另外用一个数组记录每个岛屿的面积，如下图所示。这样我们就可以发现红色方框内的海洋格子，它的「两个」相邻的岛屿实际上是同一个。

## 岛屿周长；

对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 111）加入答案 ans\textit{ans}ans 中即可。

# 反转链表

头插法



# [拓扑排序](https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/)

给定一个包含 n个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：

    对于图 G中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。

那么称该排列是图 G 的「拓扑排序」

特点：

+ 存在环就不是拓扑排序
+ 有向无环图可能有多种拓扑排序



课程表问题：

求出一种拓扑排序最优时间复杂度为o(m+n),n和m分别为节点数和边数

判断是否存在拓扑排序，至少也要进行一次完整遍历，同上时间复杂度

## 解法

### 深度优先

将深度优先搜索和拓扑排序结合起来，用一个栈存储已经搜完的节点

深度优先是「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点

> 对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索**回溯**到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。

搜索完成的节点存入栈中

u处于栈顶，而其相邻节点在栈底

对图进行一次深度优先搜索，节点回溯的时候，节点存入栈中

定义三个状态：

+ 未搜索
+ 搜索中：还没回溯到这个节点
+ 已完成：回溯到这个节点，该节点的相邻节点在栈中，符合拓扑排序



我们任取一个「未搜索」的节点开始进行深度优先搜索。

我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：

+ 如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；

+ **如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的**；

+ 如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到**(u,v) 之前的拓扑关系**，以及不用进行任何操作。

当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。

```java
class Solution {
          //存储有向图：转换给定数组
    List<List<Integer>> edges;
          
    int[] visited;
          
    boolean valid=true;
    //模拟栈，n-1为栈底
    int[] result;    
    int index;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges=new ArrayList<>();
        for(int i=0;i<numCourses;i++){
            edges.add(new ArrayList<>());
        }
        visited=new int[numCourses];
        result=new int[numCourses];
        index=numCourses-1;
        for(int[] info:prerequisites){
            //找出边表中第info[1]个表，添加节点info[0]
            //代表节点info[1]的后置邻点为info[0]
            edges.get(info[1]).add(info[0]);
        }
        for(int i=0;i<numCourses&&valid;i++){
            if(visited[i]==0){//节点处于未搜索状态
                dfs(i);
            }
        }
        if(!valid){
            return new int[0];
        }
        return result;
    }
    public void dfs(int u){
        visited[u]=1;//处于搜索中状态
        for(int v:edges.get(u)){
            if(visited[v]==0){
                dfs(v);
                if(!valid){
                    return;
                }
            }
            else if(visited[v]==1){//有环
                valid=false;
                return;
            }//如果为已完成状态，说明一入栈，u何时入栈不会影响栈内的拓扑关系
        }
        visited[u]=2;
        result[index]=u;
        index--;
    }
}
```

### 广度优先

方法一的深度优先搜索是一种「逆向思维」：最先被放入栈中的节点是在拓扑排序中最后面的节点。我们也可以使用正向思维，顺序地生成拓扑排序，这种方法也更加直观。

我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。

我们使用一个队列来进行广度优先搜索。初始时，所有入度为 000 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。

在广度优先搜索的每一步中，我们取出队首的节点 uuu：

+ 我们将 u 放入答案中；

+ 我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。



# [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)

## 基于快速排序的快速选择法（快排是典型的分治算法）

每次快排都可以永远确定枢轴元素的位置

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSort(nums,0, nums.length-1,k);
    }
    public int quickSort(int[] nums,int s,int e,int k){//挖坑法

        int pivot=nums[s];//初试坑
        int marks=s;
        int marke=e;

        while(s<e){
            while(s<e&&nums[e]>=pivot){
                e--;
            }
            nums[s]=nums[e];//e作为新坑待填
            while(s<e&&nums[s]<=pivot){
                s++;
            }
            nums[e]=nums[s];//s作为新坑待填
        }
        nums[s]=pivot;//填尾坑
        if(s+k== nums.length)
            return nums[s];//刚好为枢轴
        if(s-1>marks&&s+k> nums.length)//只遍历一侧
             return quickSort(nums,marks,s-1,k);
        else if(s-1==marks&&s+k> nums.length)
            return nums[s-1];
        if(marke>s+1&&s+k< nums.length)
            return quickSort(nums,s+1,marke,k);
        else if(s+1==marke&&s+k< nums.length)
            return nums[s+1];
        return nums[s];
    }
}
```

## 基于堆排序的选择方法

建立一个大根堆，做k-1次删除，堆顶元素就是要找的结果

熟悉**建堆**，**调整堆**，**删除**

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize= nums.length;
        buildMaxHeap(nums,heapSize);
        for(int i=nums.length-1;i>= nums.length-k+1;i--){
            swap(nums,0,i);
            heapSize--;
            maxHeapify(nums,0,heapSize);
        }
        return nums[0];
    }
    public void buildMaxHeap(int[] a,int heapSize){
        for(int i=heapSize/2;i>=0;i--){//从最后一个非叶子节点开始建立大根堆
            maxHeapify(a,i,heapSize);
        }
    }
    public void maxHeapify(int[]a,int i,int heapSize){
        int l=2*i+1,r=2*i+2,largest=i;
        if(l<heapSize&&a[l]>a[largest]){
            largest=l;
        }
        if(r<heapSize&&a[r]>a[largest]){
            largest=r;
        }
        if(largest!=i){
            swap(a,i,largest);//找到子节点中较大者交换
            maxHeapify(a,largest,heapSize);//递归调整较大子节点
        }
    }
    public void swap(int[] a,int i,int j){
        a[i]^=a[j];
        a[j]^=a[i];
        a[i]^=a[j];
    }
}
```

# 最大正方形

## 暴力法

时间复杂度：o(mn *min(m,n)^2)

空间复杂度：o(1)

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int row=matrix.length,col=matrix[0].length;
        int maxSide=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(matrix[i][j]=='1'){//以i,j作为正方形左上角
                    int curMaxSide=Math.min(row-i,col-j);//以此点开始的最大可能边长
                    maxSide=Math.max(maxSide,1);
                    for(int k=1;k<curMaxSide;k++){//边长扩大k
                        if(matrix[i+k][j+k]=='0')//判断右下角点
                            break;
                        boolean flag=true;
                        for(int m=0;m<k;m++){//判断新增下方边与右侧边是否为全1
                            if(matrix[i+k][j+m]=='0'||matrix[i+m][j+k]=='0')
                            {
                                flag=false;
                                break;
                            }
                        }
                        if(flag){
                            maxSide=Math.max(maxSide,k+1);
                        }
                        else{
                            break;
                        }

                    }
                }
            }
        }
        return maxSide*maxSide;
    }
}
```

## 动态规划

子状态：dp(i,j)表示以（i，j）点为正方形右下角的最长边长

如果(i,j)为0则dp(i,j)为0

如果(i,j)为1则dp(i,j)=Math.min(dp(i-1,j),dp(i,j-1),dp(i-1,j-1))+1;

反思，此处将子问题划分为边长，而不是面积，化成面积不好状态转移

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int row=matrix.length,col=matrix[0].length;
        int[][] dp=new int[row][col];
        int maxSide=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(i==0||j==0) {
                    dp[i][j]=matrix[i][j]-'0';
                } else
                    if(matrix[i][j]=='1'){
                        dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i][j-1],dp[i-1][j-1]))+1;
                    }
                maxSide=Math.max(maxSide,dp[i][j]);
            }
        }
        return maxSide*maxSide;
    }
}
```

# [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/)

```java
class Solution {//DFS，自底向上
    public TreeNode invertTree(TreeNode root) {
        if(root!=null){
            invertTree(root.left);
            invertTree(root.right);
            TreeNode temp=root.left;
            root.left=root.right;
            root.right=temp;
        }
        return root;
    }
}
```

```java
class Solution {//自顶向下
    public TreeNode invertTree(TreeNode root) {
        if(root!=null){
            TreeNode temp=root.left;
            root.left=root.right;
            root.right=temp;
            invertTree(root.left);
            invertTree(root.right);
        }
        return root;
    }
}
```

```java
class Solution {//迭代，借助队列
    public TreeNode invertTree(TreeNode root) {
        TreeNode node=root;
        if(root!=null){
            Queue<TreeNode> queue=new LinkedList<>();
            queue.offer(root);
            while (!queue.isEmpty()){
                root=queue.poll();
                TreeNode temp=root.left;
                root.left=root.right;
                root.right=temp;
                if(root.left!=null)
                    queue.offer(root.left);
                if(root.right!=null)
                    queue.offer(root.right);
            }
        }
        return node;
    }
}
```

# [回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/solution/wo-de-kuai-man-zhi-zhen-du-cong-tou-kai-shi-gan-ju/)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null&&head.next==null)
            return true;
        ListNode slow=head,fast=head;
        ListNode pre=head,prepre=null;//prepre为已反转好的部分，null同时还可以和后半段结尾比较
        while(fast!=null&&fast.next!=null){
            pre=slow;
            slow=slow.next;
            fast=fast.next.next;
            pre.next=prepre;
            prepre=pre;
        }
        if(fast!=null)//为奇数的时候不用比较最中间的数字，向后滑动一位即可
            slow=slow.next;
        while(pre!=null&&slow!=null){
            if(pre.val!= slow.val)
                return false;
            pre=pre.next;
            slow=slow.next;
        }
        return true;
    }
}//坏处是改变了链表结构
```

# [最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

终止条件：

+ 越过叶节点，返回null
+ root等于p,q,返回root

递推过程：

+ 递推左子树，返回left
+ 递推右子树,返回right

返回值：

+ leftright都为null,
+ leftright都为非null
+ leftright一null一非null

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
        if(root==null||root==p||root==q)
            return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null&&right==null)
            return null;
        if(left!=null&&right!=null)
            return root;
        if(left==null&&right!=null)
            return right;
        return left;
    }
}
```

# [除自身以外的数组乘积](https://leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/)

输入数组中出现 0，除法就失效了

## 左右乘积列表

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] L=new int[n];
        int[] R=new int[n];
        int[] out=new int[n];
        L[0]=1;
        R[n-1]=1;
        for(int i=1;i<n;i++){
            L[i]=L[i-1]*nums[i-1];
        }
        for(int i=n-2;i>=0;i--){
            R[i]=R[i+1]*nums[i+1];
        }
        for(int i=0;i<n;i++){
            out[i]=L[i]*R[i];
        }
        return out;
    }
}
```

## 空间复杂度为o(1)

在上述方法上改造：可以不使用L[]，R[],利用out[]数组，先当作L[]来用，遍历得到L[]的结果，然后逆序，利用一个R变量叠乘，等价于得到R[],同时R与out[]相乘（等价于L[i]*R[i])

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] out=new int[n];
        int R=1;
        out[0]=1;
        for(int i=1;i<n;i++){
            out[i]=nums[i-1]*out[i-1];
        }
        for(int i=n-2;i>=0;i--){
            R=R*nums[i+1];
            out[i]=out[i]*R;
        }
        return out;
    }
}
```

# [搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/)

## 二分法

这里是对“方法四”的“如何选出发点”的补充：

- 选左上角，往右走和往下走都增大，不能选
- 选右下角，往上走和往左走都减小，不能选
- 选左下角，往右走增大，往上走减小，可选
- 选右上角，往下走增大，往左走减小，可选

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m=matrix.length,n=matrix[0].length;
        int i=m-1,j=0;
        while(i>=0&&j<n){
            if(matrix[i][j]==target)
                return true;
            else if(matrix[i][j]>target)
                i--;
            else
                j++;
        }
        return false;
    }
}
```

# [完全平方数](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/)

解决递归中堆栈溢出的问题的一个思路就是使用动态规划（DP）技术，该技术建立在重用中间解的结果来计算终解的思想之上。

使用暴力枚举法会超出时间限制的原因很简单，因为我们重复的计算了中间解。我们以前的公式仍然是有效的。我们只需要一个更好的方法实现这个公式。

`numSquares(n)=min⁡(numSquares(n-k) + 1) ∀k∈square numbers`

要计算 numSquares(n) 的值，首先要计算 n 之前的所有值，即 numSquares(n−k)∀k∈square numbers。如果我们已经在某个地方保留了数字 n−k的解，那么就不需要使用递归计算。

基于上述所说，我么可以在以下步骤实现 DP 解决方案。

+ 几乎所有的动态规划解决方案，首先会创建一个一维或多维数组 DP 来保存中间子解的值，以及通常数组最后一个值代表最终解。注意，我们创建了一个虚构的元素 dp[0]=0 来简化逻辑，这有助于在在余数 (n-k）恰好是一个完全平方数的情况下。
+ 我们还需要预计算小于给定数字 n 的完全平方数列表（即 square）。
+ 在主要步骤中，我们从数字 1 循环到 n，计算每个数字 i 的解（即 numSquares(i)）。每次迭代中，我们将 numSquares(i) 的结果保存在 dp[i] 中。
+ 在循环结束时，我们返回数组中的最后一个元素作为解决方案的结果。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp=new int[n + 1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        int maxSquareIndex = (int)Math.sqrt(n);//开方向下取整
        int[] square = new int[maxSquareIndex + 1];
        for(int i = 1;i <= maxSquareIndex;i++) {
            square[i]=i*i;
        }
        for(int i = 1;i <= n;i++) {
            for(int k = 1;k <= maxSquareIndex && square[k] <= i;k++) {
                dp[i] = Math.min(dp[i],dp[i - square[k]] + 1);
            }
        }
        return dp[n];
    }
}
```



# [移动零](https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/)

## 非零前移，后置补零

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n=nums.length;
        int j=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=0){
                nums[j]=nums[i];
                j++;
            }
        }
        while(j< n){
            nums[j]=0;
            j++;
        }
    }
}
```

## 一次遍历（参考快排）

参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点`x`，然后把所有小于等于`x`的元素放到x的左边，大于x的元素放到其右边。

这里我们可以用`0`当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n= nums.length;
        for(int i=0,j=0;i<n;i++) {
            if (nums[i] != 0) {
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j++] = tmp;
            }
        }
    }
}
```

**注意一个大坑：这里不要用异或炫技，原地异或就会永久变0**

# 寻找重复数（*这个题我还不会，只会哈希与排序*）

思路：如果题目不限制：

+ 不能更改原数组（假设数组是只读的）；
+ 只能使用额外的 O(1) 的空间。

容易想到的方法有：

+ 使用哈希表判重，这违反了限制 2；
+ 将原始数组排序，排序以后，重复的数相邻，即找到了重复数，这违反了限制 1；（堆排序可以O(1)空间复杂度）
+ 使用类似「力扣」第 41 题：缺失的第一个正数 （原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重复的元素，这违反了限制 1；
+ 既然要定位数，这个数恰好是一个整数，可以在「整数的有效范围内」做二分查找，但是比较烦的一点是得反复看整个数组好几次，本题解就介绍通过二分法定位一个有范围的整数；
+ 还可以使用「快慢指针」来完成，不过这种做法太有技巧性了，不是通用的做法，可以查看官方题解。

# [最长上升子序列]()

定义 dp[i]考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，**注意 nums[i] 必须被选取**。

我们从小到大计算 dp数组的值，在计算 dp[i]之前，我们已经计算出 dp[0…i−1]的值，则状态转移方程为：

dp[i]=max⁡(dp[j])+1,其中 0≤j<i 且 num[j]<num[i]

> 「无后效性」的设计思想：让不确定的因素确定下来，以保证求解的过程形成一个逻辑上的有向无环图。这题不确定的因素是某个元素是否被选中，而我们设计状态的时候，让 nums[i] 必需被选中，这一点是「让不确定的因素确定下来」，也是我们这样设计状态的原因。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        Arrays.fill(dp,1);
        int max=1;
        for(int i=1;i<n;i++)
        {
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]) {
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
            max=Math.max(dp[i],max);
        }
        return max;
    }
}
```

「动态规划」的方法在计算一个新的状态的时候，需要考虑到之前所有小于 `nums[i]` 的那些位置的状态。事实上还有改进的空间：首先修改「状态」的定义。

状态设计思想：依然着眼于某个上升子序列的 结尾的元素，如果 已经得到的上升子序列的结尾的数越小，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，这样定义以后容易得到「状态转移方程」。

为了与「方法二」的状态定义区分，将状态数组命名为 tail。

# [零钱兑换]()

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        int n=coins.length;
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            boolean exist=false;
            for(int j=0;j<n;j++){
                if (coins[j] <= i&&dp[i - coins[j]]!=-1) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                    exist=true;//存在组合方法
                }
            }
            if(!exist)
                dp[i]=-1;
        }
        return dp[amount];
    }
}
```

另一种赋初值方法

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;//保证不会溢出
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

# [打家劫舍Ⅲ]()

```java
/**
暴力法
*/
class Solution {
    public int rob(TreeNode root) {
        return Math.max(rob(root,true),rob(root,false));
    }
    public int rob(TreeNode root,boolean robRoot){
        if(root==null)
            return 0;
        int ans = 0;
        if (robRoot == false) {
            int maxleft = Math.max(rob(root.left, true), rob(root.left, false));
            int maxrright = Math.max(rob(root.right, true), rob(root.right, false));
            ans = maxleft + maxrright;
        } else {
            ans = root.val + rob(root.left, false) + rob(root.right, false);
        }
        return ans;
    }
}
```

针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。

我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。

由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value

```java
class Solution {
    public int rob(TreeNode root) {
        Map<TreeNode,Integer> map=new HashMap<>();
        return rob(root,map);
    }
    public int rob(TreeNode root,Map<TreeNode,Integer> map){
        if(root==null){
            return 0;
        }
        int ans=root.val;
        if(map.containsKey(root)) {
            return map.get(root);
        } else {
            if(root.left!=null)
                ans+=rob(root.left.left,map)+rob(root.left.right,map);
            if(root.right!=null)
                ans+=rob(root.right.left,map)+rob(root.right.right,map);
        }
        ans=Math.max(ans,rob(root.left,map)+rob(root.right,map));
        map.put(root,ans);
        return ans;
    }
}
```

解法三和解法二看似时间复杂度都是O(n)，但是解法二比解法三多了很多函数调用，在函数调用过程中，压栈出栈需要消耗性能，

我们可以做一个小小的优化，我们发现无论是 f(o) 还是 g(o)，他们最终的值只和 f(l)、g(l)、f(r)、g(r) 有关，所以对于每个节点，我们只关心它的孩子节点们的 f 和 g 是多少。我们可以设计一个结构，表示某个节点的 f 和 g 值，在每次递归返回的时候，都把这个点对应的 f 和 g 返回给上一级调用，这样可以省去哈希表的空间。

```java
class Solution {
    public int rob(TreeNode root) {
        Map<TreeNode,Integer> map=new HashMap<>();
        int[] ints = robInternal(root);
        return Math.max(ints[0],ints[1]);
    }
    public int[] robInternal(TreeNode root){
        if(root==null){
            return new int[2];
        }
        int[] res=new int[2];
        int[] left=robInternal(root.left);
        int[] right=robInternal(root.right);
        res[0]=Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        res[1]=left[0]+right[0]+root.val;
        return res;
    }
}
```

# [比特位计数]()

```java
class Solution {
    public int[] countBits(int num) {
        int[] dp=new int[num+1];
        dp[0]=0;
        for(int i=1;i<=num;i++){
            if((i&1)==0){
                dp[i]=dp[i>>1];
            }
            else
                dp[i]=dp[i-1]+1;
        }
        return dp;
    }
}
```

```java
//改进版
class Solution {
    public int[] countBits(int num) {
        int[] dp=new int[num+1];
        dp[0]=0;
        for(int i=1;i<=num;i++){
            dp[i]=dp[i>>1]+(1&i);
        }
        return dp;
    }
}
```

# [前k个高频元素]()

采用优先队列：维持一个大小为K的最小堆，每次和堆顶的最小元素比较，如果大于堆顶元素，则出队，然后此元素入队；如果小于堆顶，则无需处理。

具体操作为：

+ 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率
+ 维护一个元素数目为 k 的最小堆
+ 每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较
+ 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中
+ 最终，堆中的 k 个元素即为前 k 个高频元素



```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>();
        int n=nums.length;
        for(int i=0;i<n;i++){
            if(map.containsKey(nums[i])){
                map.put(nums[i],map.get(nums[i])+1);
            } else{
                map.put(nums[i],1);
            }
        }
        PriorityQueue<Integer> pq=new PriorityQueue<>(//java中默认取权值小为根
                new Comparator<Integer>() {//实现Comparator的匿名内部类
                    @Override
                    public int compare(Integer o1, Integer o2) {
                        return map.get(o1)- map.get(o2);//返回负数，则代表前者小于后者
                    }
                }
        );
        for(Integer key:map.keySet()){
            if(pq.size()<k){
                pq.offer(key);
            }else if(map.get(key)>map.get(pq.peek())){
                pq.poll();
                pq.offer(key);
            }
        }
        int[] ans=new int[k];
        for(int i=0;i<k;i++){
            ans[i]=pq.poll();
        }
        return ans;
    }
}
```

```java
//桶排序，频率作为桶的下标
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>();
        int n=nums.length;
        int[] res=new int[k];
        for(int num:nums){
            if(map.containsKey(num)){
                map.put(num,map.get(num)+1);
            } else{
                map.put(num,1);
            }
        }
        List<Integer>[] list=new List[n+1];//桶
        for(int key:map.keySet()){
            int i=map.get(key);
            if(list[i]==null){
                list[i]=new ArrayList<>();
            }
            list[i].add(key);
        }
        for(int i= list.length-1,j=0;i>=0&&j<k;i--){
            if(list[i]==null){
                continue;
            }
            for(int num:list[i]){
                if(j<k)
                    res[j++]=num;
                else
                    break;
            }
        }
        return res;
    }
}
```

# [字符串解码]()

压栈需要保存信息的包括res和multi,

```java
class Solution {
    public String decodeString(String s) {
        int n=s.length();
        Deque<Integer> stk_multi=new LinkedList<>();
        Deque<String> stk_res=new LinkedList<>();
        int multi=0;
        StringBuffer res=new StringBuffer();
        for(char ch:s.toCharArray()){
            if(ch=='['){//此刻需要压栈记录res ,multi
                stk_multi.push(multi);
                stk_res.push(res.toString());
                multi=0;
                res=new StringBuffer();
            }else if(ch==']'){//出栈，叠加multi次res,连接stk_res栈顶的上次记录的前缀res,作为新res
                StringBuffer temp=new StringBuffer();
                int cur_multi=stk_multi.pop();
                for(int i=0;i<cur_multi;i++){
                    temp.append(res);
                }
                res=new StringBuffer(stk_res.pop()+temp);
            }else if(ch>='0'&&ch<='9'){
                multi=multi*10+(ch-'0');
            }else {
                res.append(ch);
            }
        }
        return res.toString();
    }
}
```

```java
//不同点在于将 [ 和 ] 分别作为递归的开启与终止条件
class Solution {
    public String decodeString(String s) {
        return dfs(s,0)[0];
    }
    private String[] dfs(String s,int i){//String[0]记录一层dfs结束后，] 的位置，String[1]记录一层dfs结束后的res
        StringBuilder res=new StringBuilder();
        int multi=0;
        while(i<s.length()){
            char ch=s.charAt(i);
            if(ch>='0'&&ch<='9'){
                multi=multi*10+ch-'0';
            }else if(ch=='['){//'['作为dfs开始条件
                String[] temp=dfs(s,i+1);
                i=Integer.parseInt(temp[0]);//新位置
                while(multi>0){
                    res.append(temp[1]);
                    multi--;//减为0
                }
            }else if(ch==']'){//'['作为dfs结束条件
                return new String[]{String.valueOf(i), res.toString()};
            }else{
                res.append(ch);
            }
            i++;
        }
        return new String[]{res.toString()};
    }
}
```

# [根据身高重置队列]()

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        int[][] queue=new int[people.length][];//此处列标有初值，默认为初值为0的矩阵；此处列表无初值，则为初值为null的一维数组
        Arrays.sort(people, new Comparator<int[]>() {
                    @Override
                    public int compare(int[] o1, int[] o2) {
                        if(o1[0]==o2[0])
                            return -(o1[1]-o2[1]);
                        return o1[0]-o2[0];
                    }
                }
        );
        for(int[] peo:people){
            int j=0;
            for(int count=0;count<peo[1];j++){
                if(queue[j]==null) {
                    count++;
                }
            }
            while(queue[j]!=null){
                j++;
            }
            queue[j]=peo;
        }
        return queue;
    }
}
```

# [找到所有数组中消失的数字]()

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n=nums.length;
        int[] mark=new int[n];
        for(int num:nums){
            mark[num-1]=-1;//因为范围在[1,n],所以可用长度为n的数组当作哈希表
        }
        List<Integer> list=new ArrayList<>();
        for(int m=0;m<n;m++){
            if(mark[m]==0){
                list.add(m+1);
            }
        }
        return list;
    }
}
```



```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n=nums.length;
        for(int num:nums){
            int x=(num-1)%n;
            nums[x]+=n;
        }
        List<Integer> list=new ArrayList<>();
        for(int i=0;i<n;i++){
            if(nums[i]<=n)
                list.add(i+1);
        }
        return list;
    }
}
```

# [海明距离]()

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res=x^y;
        int count=0;
        while(res>0){
            res&=(res-1);//每次位与，移除最后一位1
            count++;
        }
        return count;
    }
}
```

# [二叉树的直径]()

一条路径的长度等于节点数减1

任意一条路径可以看作某个节点为起点，从左儿子和右儿子向下遍历得到的最长路径拼接起来。

```java
class Solution {
    int max;//最多节点数
    public int diameterOfBinaryTree(TreeNode root) {
        max=1;
        depth(root);
        return max-1;
    }
    public int depth(TreeNode root){
        if(root==null)
            return 0;
        int L=depth(root.left);//左儿子向下遍历经历的最多节点数
        int R=depth(root.right);
        max=Math.max(max,L+R+1);
        return Math.max(L,R)+1;
    }
}
```

# [和为K的子数组]()

```Java
//暴力枚举，时间复杂度o(n^2),用时很长
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n= nums.length;
        int count=0;
        for(int i=0;i<n;i++){//枚举以i开头的子数组
            int sum=0;
            for(int j=i;j<n;j++){
                sum+=nums[j];
                if(sum==k)
                    count++;
            }
        }
        return count;
    }
}
```

在上述方法上继续优化，瓶颈在于每个i重复枚举j,计算了重复的和

pre[i]为[0..i]前缀和

p[i]-p[j]==k

考虑以i结尾的子数组只要统计铅笔那出现多少次前缀和pre[i]-k

从左往右边更新map,边统计次数

pre使用滚动数组

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count=0;
        int pre=0;
        int n= nums.length;
        Map<Integer,Integer> map=new HashMap<>();
        map.put(0,1);
        for(int i=0;i<n;i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                count+=map.get(pre-k);
            }
            map.put(pre,map.getOrDefault(pre,0)+1);
        }
        return count;
    }
}
```

# [最短无序连续子数组]()

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        Deque<Integer> stk=new LinkedList<>();
        int n= nums.length;
        int left= nums.length-1;
        int right=0;
        for(int i=0;i<n;i++){
            while(!stk.isEmpty()&&nums[i]< nums[stk.peek()])
                left=Math.min(left,stk.pop());
            stk.push(i);
        }
        stk.clear();
        for(int i=n-1;i>=0;i--){
            while(!stk.isEmpty()&&nums[i]> nums[stk.peek()])
                right=Math.max(right,stk.pop());
            stk.push(i);
        }
        return  right-left>0?right-left+1:0;
    }
}
```

这个方法背后的想法仍然是选择排序。我们需要找到无序子数组中最小元素和最大元素分别对应的正确位置，来求得我们想要的无序子数组的边界。

为了达到这一目的，此方法中，我们使用 单调栈 。我们从头遍历 nums 数组，如果遇到的数字大小一直是升序的，我们就不断把对应的下标压入栈中，这么做的目的是因为这些元素在目前都是处于正确的位置上。一旦我们遇到前面的数比后面的数大，也就是 nums[j]比栈顶元素小，我们可以知道 nums[j] 一定不在正确的位置上。

为了找到 nums[j]的正确位置，我们不断将栈顶元素弹出，直到栈顶元素比 nums[j] 小，我们假设栈顶元素对应的下标为 k ，那么我们知道 nums[j] 的正确位置下标应该是 k+1 。

我们重复这一过程并遍历完整个数组，这样我们可以找到最小的 k， 它也是无序子数组的左边界。

